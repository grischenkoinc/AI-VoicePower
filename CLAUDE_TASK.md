# –ü—Ä–æ–º–ø—Ç –¥–ª—è Claude Code ‚Äî Phase 5.3: Debate + Sales Pitch (AI-Interactive)

## –ö–æ–Ω—Ç–µ–∫—Å—Ç

–ü—Ä–æ–¥–æ–≤–∂—É—é —Ä–æ–∑—Ä–æ–±–∫—É AI VoicePower. –ó–∞–≤–µ—Ä—à–µ–Ω—ñ —Ñ–∞–∑–∏:
- ‚úÖ Phase 0.1-0.6 ‚Äî Infrastructure  
- ‚úÖ Phase 1.1-1.4 ‚Äî Onboarding + Diagnostic
- ‚úÖ Phase 2.1-2.5 ‚Äî Warmup
- ‚úÖ Phase 3 ‚Äî Home Screen
- ‚úÖ Phase 4.1-4.4 ‚Äî Courses (–ø–æ–≤–Ω—ñ—Å—Ç—é)
- ‚úÖ Phase 5.1 ‚Äî Improvisation Hub + Random Topic
- ‚úÖ Phase 5.2 ‚Äî Storytelling + Daily Challenge

–ó–∞—Ä–∞–∑ **Phase 5.3 ‚Äî Debate + Sales Pitch** ‚Äî –æ—Å—Ç–∞–Ω–Ω—è –ø—ñ–¥—Ñ–∞–∑–∞ Phase 5, –Ω–∞–π—Å–∫–ª–∞–¥–Ω—ñ—à–∞.

**–ó–≥—ñ–¥–Ω–æ –∑ PHASE_STRUCTURE_GUIDE.md**: –í–∏—Å–æ–∫–∞ —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å, AI-interaction.

**–°–ø–µ—Ü–∏—Ñ—ñ–∫–∞—Ü—ñ—è:** `SPECIFICATION.md`, —Å–µ–∫—Ü—ñ—ó 4.3.7 (Improvisation Screen) + 5.5 (ImprovisationTask) + 8.2 (AI System Prompts).

**–°–∫–ª–∞–¥–Ω—ñ—Å—Ç—å:** üî¥ –í–ò–°–û–ö–ê (Gemini API integration!)  
**–ß–∞—Å:** ‚è±Ô∏è 4-5 –≥–æ–¥–∏–Ω

---

## ‚ö° –ö–†–ò–¢–ò–ß–ù–û –í–ê–ñ–õ–ò–í–û

**–¶–µ –ø–µ—Ä—à–∞ —Ä–µ–∞–ª—å–Ω–∞ Gemini API —ñ–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è –≤ –ø—Ä–æ–µ–∫—Ç—ñ!**

Phase 5.3 ‚Äî —Ü–µ **proof of concept** –¥–ª—è:
- Real-time AI conversation
- Turn-based interaction
- Streaming responses (–æ–ø—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ)
- Error handling
- Rate limiting

Phase 6 (AI Coach) –±—É–¥–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ —Ç—É —Å–∞–º—É —ñ–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä—É.

---

## –ö–ª—é—á–æ–≤–∞ —ñ–¥–µ—è

**Phase 5.3** –¥–æ–¥–∞—î 2 AI-powered —Ä–µ–∂–∏–º–∏:

### 1. Debate (–î–µ–±–∞—Ç–∏ –∑ AI)
- –ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –æ–±–∏—Ä–∞—î —Ç–µ–º—É —Ç–∞ –ø–æ–∑–∏—Ü—ñ—é (–ó–ê/–ü–†–û–¢–ò)
- AI –≥—Ä–∞—î –æ–ø–æ–Ω–µ–Ω—Ç–∞ –∑ –ø—Ä–æ—Ç–∏–ª–µ–∂–Ω–æ—é –ø–æ–∑–∏—Ü—ñ—î—é
- **Turn-based**: User –∞—Ä–≥—É–º–µ–Ω—Ç ‚Üí AI –∫–æ–Ω—Ç—Ä–∞—Ä–≥—É–º–µ–Ω—Ç ‚Üí User –≤—ñ–¥–ø–æ–≤—ñ–¥—å
- 3-5 —Ä–∞—É–Ω–¥—ñ–≤
- AI –∞–Ω–∞–ª—ñ–∑—É—î –∞—Ä–≥—É–º–µ–Ω—Ç–∏ —Ç–∞ –≥–µ–Ω–µ—Ä—É—î –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ

### 2. Sales Pitch (–ü—Ä–æ–¥–∞–∂ –∑ AI-–∫–ª—ñ—î–Ω—Ç–æ–º)
- –ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –æ–±–∏—Ä–∞—î —Ç–æ–≤–∞—Ä (—Ä–µ–∞–ª—å–Ω–∏–π –∞–±–æ –∞–±—Å—É—Ä–¥–Ω–∏–π)
- AI –≥—Ä–∞—î –∫–ª—ñ—î–Ω—Ç–∞ –∑ –∑–∞–ø–µ—Ä–µ—á–µ–Ω–Ω—è–º–∏
- **Interactive**: User pitch ‚Üí AI –∑–∞–ø–∏—Ç–∞–Ω–Ω—è ‚Üí User –≤—ñ–¥–ø–æ–≤—ñ–¥—å ‚Üí AI decision
- AI —Å–∏–º—É–ª—é—î —Ä—ñ–∑–Ω—ñ —Ç–∏–ø–∏ –∫–ª—ñ—î–Ω—Ç—ñ–≤

---

## Debate Flow

```
ImprovisationScreen
    ‚îÇ
    ‚ñº
Click "–î–µ–±–∞—Ç–∏ –∑ AI"
    ‚îÇ
    ‚ñº
DebateScreen
    ‚îÇ
    ‚îú‚îÄ –í–∏–±—ñ—Ä —Ç–µ–º–∏ (–∑ DebateTopicsProvider)
    ‚îú‚îÄ –í–∏–±—ñ—Ä –ø–æ–∑–∏—Ü—ñ—ó (–ó–ê/–ü–†–û–¢–ò)
    ‚îÇ
    ‚ñº
–°—Ç–∞—Ä—Ç –¥–µ–±–∞—Ç—ñ–≤ (Round 1)
    ‚îÇ
    ‚îú‚îÄ User: –∑–∞–ø–∏—Å—É—î –∞—Ä–≥—É–º–µ–Ω—Ç (60 —Å–µ–∫)
    ‚îú‚îÄ Transcription (SpeechRecognizer)
    ‚îú‚îÄ –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è RecordingEntity
    ‚îÇ
    ‚ñº
AI Response (Round 1)
    ‚îÇ
    ‚îú‚îÄ Send user argument ‚Üí Gemini API
    ‚îú‚îÄ AI –≥–µ–Ω–µ—Ä—É—î –∫–æ–Ω—Ç—Ä–∞—Ä–≥—É–º–µ–Ω—Ç
    ‚îú‚îÄ Show AI response (text)
    ‚îÇ
    ‚ñº
Round 2, 3... (–¥–æ 5 —Ä–∞—É–Ω–¥—ñ–≤)
    ‚îÇ
    ‚ñº
Debate Completed
    ‚îÇ
    ‚îú‚îÄ Show summary
    ‚îú‚îÄ AI –æ—Ü—ñ–Ω—é—î –∞—Ä–≥—É–º–µ–Ω—Ç–∞—Ü—ñ—é
    ‚îî‚îÄ Save full debate
```

---

## Sales Pitch Flow

```
ImprovisationScreen
    ‚îÇ
    ‚ñº
Click "–ü—Ä–æ–¥–∞–∂ —Ç–æ–≤–∞—Ä—É"
    ‚îÇ
    ‚ñº
SalesPitchScreen
    ‚îÇ
    ‚îú‚îÄ –í–∏–±—ñ—Ä —Ç–æ–≤–∞—Ä—É (–∑ SalesProductsProvider)
    ‚îú‚îÄ AI –≥–µ–Ω–µ—Ä—É—î customer profile
    ‚îÇ
    ‚ñº
Opening Pitch
    ‚îÇ
    ‚îú‚îÄ User: –∑–∞–ø–∏—Å—É—î pitch (90 —Å–µ–∫)
    ‚îú‚îÄ Transcription
    ‚îú‚îÄ –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è recording
    ‚îÇ
    ‚ñº
AI Customer Response
    ‚îÇ
    ‚îú‚îÄ Send pitch ‚Üí Gemini API
    ‚îú‚îÄ AI: –∑–∞–ø–∏—Ç–∞–Ω–Ω—è –∞–±–æ –∑–∞–ø–µ—Ä–µ—á–µ–Ω–Ω—è
    ‚îú‚îÄ Show AI response
    ‚îÇ
    ‚ñº
User Handles Objection
    ‚îÇ
    ‚îú‚îÄ User: –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î (60 —Å–µ–∫)
    ‚îú‚îÄ Transcription
    ‚îÇ
    ‚ñº
AI Decision
    ‚îÇ
    ‚îú‚îÄ Send response ‚Üí Gemini API
    ‚îú‚îÄ AI: "–ö—É–ø—É—é" –∞–±–æ "–ù–µ –ø–µ—Ä–µ–∫–æ–Ω–∞–≤"
    ‚îú‚îÄ AI –ø–æ—è—Å–Ω—é—î —Ä—ñ—à–µ–Ω–Ω—è
    ‚îÇ
    ‚ñº
Sales Completed
    ‚îî‚îÄ Show result + feedback
```

---

## –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ñ–∞–π–ª—ñ–≤

```
data/remote/
‚îú‚îÄ‚îÄ GeminiApiClient.kt
‚îî‚îÄ‚îÄ dto/
    ‚îú‚îÄ‚îÄ GeminiRequest.kt
    ‚îî‚îÄ‚îÄ GeminiResponse.kt

data/content/
‚îú‚îÄ‚îÄ DebateTopicsProvider.kt
‚îî‚îÄ‚îÄ SalesProductsProvider.kt

ui/screens/improvisation/
‚îú‚îÄ‚îÄ DebateScreen.kt
‚îú‚îÄ‚îÄ DebateViewModel.kt
‚îú‚îÄ‚îÄ DebateState.kt
‚îú‚îÄ‚îÄ DebateEvent.kt
‚îÇ
‚îú‚îÄ‚îÄ SalesPitchScreen.kt
‚îú‚îÄ‚îÄ SalesPitchViewModel.kt
‚îú‚îÄ‚îÄ SalesPitchState.kt
‚îú‚îÄ‚îÄ SalesPitchEvent.kt
‚îÇ
‚îî‚îÄ‚îÄ components/
    ‚îú‚îÄ‚îÄ DebateTopicCard.kt
    ‚îú‚îÄ‚îÄ DebateRoundCard.kt
    ‚îú‚îÄ‚îÄ AiResponseCard.kt
    ‚îú‚îÄ‚îÄ SalesProductCard.kt
    ‚îî‚îÄ‚îÄ CustomerProfileCard.kt
```

---

## –ü–æ–≤–Ω–∏–π –∫–æ–¥

### 1. GeminiApiClient.kt

```kotlin
package com.aivoicepower.data.remote

import android.content.Context
import com.google.ai.client.generativeai.GenerativeModel
import com.google.ai.client.generativeai.type.Content
import com.google.ai.client.generativeai.type.GenerateContentResponse
import com.google.ai.client.generativeai.type.generationConfig
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.flow.Flow
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Client –¥–ª—è —Ä–æ–±–æ—Ç–∏ –∑ Gemini API
 */
@Singleton
class GeminiApiClient @Inject constructor(
    @ApplicationContext private val context: Context
) {
    
    companion object {
        // TODO: Move to BuildConfig or secure storage
        private const val API_KEY = "YOUR_GEMINI_API_KEY_HERE"
        private const val MODEL_NAME = "gemini-1.5-flash-latest" // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ Flash –¥–ª—è —à–≤–∏–¥–∫–æ—Å—Ç—ñ
    }
    
    private val generativeModel = GenerativeModel(
        modelName = MODEL_NAME,
        apiKey = API_KEY,
        generationConfig = generationConfig {
            temperature = 0.8f
            topK = 40
            topP = 0.95f
            maxOutputTokens = 800
        }
    )
    
    /**
     * –ì–µ–Ω–µ—Ä—É—î –≤—ñ–¥–ø–æ–≤—ñ–¥—å –¥–ª—è –¥–µ–±–∞—Ç—ñ–≤
     */
    suspend fun generateDebateResponse(
        topic: String,
        userPosition: String,
        userArgument: String,
        roundNumber: Int,
        conversationHistory: List<Pair<String, String>> = emptyList()
    ): Result<String> {
        return try {
            val systemPrompt = buildDebateSystemPrompt(topic, userPosition, roundNumber)
            val userPrompt = buildDebateUserPrompt(userArgument, conversationHistory)
            
            val response = generativeModel.generateContent(
                content {
                    text(systemPrompt)
                    text(userPrompt)
                }
            )
            
            val aiResponse = response.text ?: "–Ø –Ω–µ –º–æ–∂—É –≤—ñ–¥–ø–æ–≤—ñ—Å—Ç–∏ –Ω–∞ —Ü–µ–π –∞—Ä–≥—É–º–µ–Ω—Ç."
            Result.success(aiResponse)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * –ì–µ–Ω–µ—Ä—É—î –≤—ñ–¥–ø–æ–≤—ñ–¥—å AI-–∫–ª—ñ—î–Ω—Ç–∞ —É –ø—Ä–æ–¥–∞–∂–∞—Ö
     */
    suspend fun generateSalesResponse(
        product: String,
        customerType: String,
        userPitch: String,
        interactionStage: SalesStage
    ): Result<String> {
        return try {
            val systemPrompt = buildSalesSystemPrompt(product, customerType, interactionStage)
            val userPrompt = "–ü—Ä–æ–¥–∞–≤–µ—Ü—å –∫–∞–∂–µ: $userPitch"
            
            val response = generativeModel.generateContent(
                content {
                    text(systemPrompt)
                    text(userPrompt)
                }
            )
            
            val aiResponse = response.text ?: "–ú–µ–Ω—ñ –ø–æ—Ç—Ä—ñ–±–Ω–æ –ø–æ–¥—É–º–∞—Ç–∏..."
            Result.success(aiResponse)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    /**
     * –û—Ü—ñ–Ω—é—î —Ñ—ñ–Ω–∞–ª—å–Ω–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–µ–±–∞—Ç—ñ–≤
     */
    suspend fun evaluateDebate(
        topic: String,
        userPosition: String,
        rounds: List<Pair<String, String>>
    ): Result<String> {
        return try {
            val prompt = buildDebateEvaluationPrompt(topic, userPosition, rounds)
            
            val response = generativeModel.generateContent(prompt)
            
            val evaluation = response.text ?: "–ì–∞—Ä–Ω–∞ —Å–ø—Ä–æ–±–∞!"
            Result.success(evaluation)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    // ===== SYSTEM PROMPTS =====
    
    private fun buildDebateSystemPrompt(
        topic: String,
        userPosition: String,
        roundNumber: Int
    ): String {
        val oppositePosition = if (userPosition == "–ó–ê") "–ü–†–û–¢–ò" else "–ó–ê"
        
        return """
–¢–∏ ‚Äî –æ–ø–æ–Ω–µ–Ω—Ç —É –¥–µ–±–∞—Ç–∞—Ö –Ω–∞ —Ç–µ–º—É: "$topic"
–¢–≤–æ—è –ø–æ–∑–∏—Ü—ñ—è: $oppositePosition
–†–∞—É–Ω–¥: $roundNumber –∑ 5

–¢–≤–æ—ó –∑–∞–¥–∞—á—ñ:
1. –í–∏–∑–Ω–∞–π —á–∞—Å—Ç–∫–æ–≤–æ –ø—Ä–∞–≤–∏–ª—å–Ω—ñ –º–æ–º–µ–Ω—Ç–∏ –≤ –∞—Ä–≥—É–º–µ–Ω—Ç—ñ –æ–ø–æ–Ω–µ–Ω—Ç–∞
2. –ù–∞–≤–µ–¥–∏ —Å–∏–ª—å–Ω–∏–π –∫–æ–Ω—Ç—Ä–∞—Ä–≥—É–º–µ–Ω—Ç –Ω–∞ –ø–æ–∑–∏—Ü—ñ—é $oppositePosition
3. –ü–æ—Å—Ç–∞–≤—å 1 —É—Ç–æ—á–Ω—é—é—á–µ –ø–∏—Ç–∞–Ω–Ω—è –∞–±–æ –≤–∏–∫–ª–∏–∫

–ü—Ä–∞–≤–∏–ª–∞:
- –í—ñ–¥–ø–æ–≤—ñ–¥–∞–π —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é –º–æ–≤–æ—é
- –ë—É–¥—å –ª–æ–≥—ñ—á–Ω–∏–º, –∞–ª–µ –Ω–µ –∞–≥—Ä–µ—Å–∏–≤–Ω–∏–º
- –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π —Ñ–∞–∫—Ç–∏ —Ç–∞ –ª–æ–≥—ñ–∫—É
- –î–æ–≤–∂–∏–Ω–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ: 2-4 —Ä–µ—á–µ–Ω–Ω—è
- –ë–µ–∑ –æ—Å–æ–±–∏—Å—Ç–∏—Ö –Ω–∞–ø–∞–¥—ñ–≤

–°—Ç–∏–ª—å: –∞–∫–∞–¥–µ–º—ñ—á–Ω–∏–π, –∞–ª–µ –∑—Ä–æ–∑—É–º—ñ–ª–∏–π
        """.trimIndent()
    }
    
    private fun buildDebateUserPrompt(
        userArgument: String,
        history: List<Pair<String, String>>
    ): String {
        val historyText = if (history.isNotEmpty()) {
            "–ü–æ–ø–µ—Ä–µ–¥–Ω—ñ —Ä–∞—É–Ω–¥–∏:\n" + history.joinToString("\n") { (user, ai) ->
                "–û–ø–æ–Ω–µ–Ω—Ç: $user\n–¢–∏: $ai"
            } + "\n\n"
        } else ""
        
        return "${historyText}–û–ø–æ–Ω–µ–Ω—Ç —â–æ–π–Ω–æ –Ω–∞–≤—ñ–≤ –∞—Ä–≥—É–º–µ–Ω—Ç:\n\"$userArgument\"\n\n–¢–≤–æ—è –≤—ñ–¥–ø–æ–≤—ñ–¥—å:"
    }
    
    private fun buildSalesSystemPrompt(
        product: String,
        customerType: String,
        stage: SalesStage
    ): String {
        return when (stage) {
            SalesStage.INITIAL_PITCH -> """
–¢–∏ ‚Äî –ø–æ—Ç–µ–Ω—Ü—ñ–π–Ω–∏–π –∫–ª—ñ—î–Ω—Ç, —è–∫–æ–º—É –ø—Ä–æ–¥–∞—é—Ç—å: "$product"
–¢–≤—ñ–π —Ç–∏–ø: $customerType

–ü—Ä–æ–¥–∞–≤–µ—Ü—å —â–æ–π–Ω–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏–≤ —Ç–æ–≤–∞—Ä. –¢–≤–æ—è —Ä–µ–∞–∫—Ü—ñ—è:
1. –í–∏—Å–ª–æ–≤–ª—é–π –ø—Ä–∏—Ä–æ–¥–Ω—É —Ü—ñ–∫–∞–≤—ñ—Å—Ç—å –∞–±–æ —Å–∫–µ–ø—Ç–∏—Ü–∏–∑–º (–∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ —Ç–∏–ø—É)
2. –ü–æ—Å—Ç–∞–≤ 1-2 –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ñ –∑–∞–ø–∏—Ç–∞–Ω–Ω—è –ø—Ä–æ –ø—Ä–æ–¥—É–∫—Ç
3. –í–∏—Å—É–Ω—å —Ç–∏–ø–æ–≤–µ –∑–∞–ø–µ—Ä–µ—á–µ–Ω–Ω—è –¥–ª—è —Ç–≤–æ–≥–æ —Ç–∏–ø—É –∫–ª—ñ—î–Ω—Ç–∞

–ü—Ä–∞–≤–∏–ª–∞:
- –í—ñ–¥–ø–æ–≤—ñ–¥–∞–π —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é –º–æ–≤–æ—é
- –ë—É–¥—å —Ä–µ–∞–ª—ñ—Å—Ç–∏—á–Ω–∏–º –∫–ª—ñ—î–Ω—Ç–æ–º
- –î–æ–≤–∂–∏–Ω–∞: 2-3 —Ä–µ—á–µ–Ω–Ω—è
- –ë–µ–∑ –≤—ñ–¥—Ä–∞–∑—É –ø–æ–≥–æ–¥–∂—É–≤–∞—Ç–∏—Å—è –∞–±–æ –≤—ñ–¥–º–æ–≤–ª—è—Ç–∏—Å—è
            """.trimIndent()
            
            SalesStage.HANDLING_OBJECTION -> """
–¢–∏ ‚Äî –ø–æ—Ç–µ–Ω—Ü—ñ–π–Ω–∏–π –∫–ª—ñ—î–Ω—Ç, —è–∫–∏–π —Å–ª—É—Ö–∞—î –≤—ñ–¥–ø–æ–≤—ñ–¥—å –Ω–∞ —Å–≤–æ—î –∑–∞–ø–µ—Ä–µ—á–µ–Ω–Ω—è.
–ü—Ä–æ–¥—É–∫—Ç: "$product"
–¢–≤—ñ–π —Ç–∏–ø: $customerType

–ü—Ä–æ–¥–∞–≤–µ—Ü—å —â–æ–π–Ω–æ –≤—ñ–¥–ø–æ–≤—ñ–≤ –Ω–∞ —Ç–≤–æ—î –∑–∞–ø–µ—Ä–µ—á–µ–Ω–Ω—è. –¢–µ–ø–µ—Ä –ø—Ä–∏–π–º–∏ —Ä—ñ—à–µ–Ω–Ω—è:
1. –Ø–∫—â–æ –≤—ñ–¥–ø–æ–≤—ñ–¥—å –ø–µ—Ä–µ–∫–æ–Ω–ª–∏–≤–∞ ‚Üí –ó–≥–æ–¥—å—Å—è –∫—É–ø–∏—Ç–∏ + –ø–æ—è—Å–Ω–∏ —á–æ–º—É
2. –Ø–∫—â–æ –≤—ñ–¥–ø–æ–≤—ñ–¥—å —Å–ª–∞–±–∫–∞ ‚Üí –í–≤—ñ—á–ª–∏–≤–æ –≤—ñ–¥–º–æ–≤—Å—è + –ø–æ—è—Å–Ω–∏ –ø—Ä–∏—á–∏–Ω—É

–ü—Ä–∞–≤–∏–ª–∞:
- –ë—É–¥—å —á–µ—Å–Ω–∏–º, –∞–ª–µ –Ω–µ –∂–æ—Ä—Å—Ç–æ–∫–∏–º
- –û—Ü—ñ–Ω–∏ —è–∫—ñ—Å—Ç—å –∞—Ä–≥—É–º–µ–Ω—Ç–∞—Ü—ñ—ó –ø—Ä–æ–¥–∞–≤—Ü—è
- –î–æ–≤–∂–∏–Ω–∞: 2-3 —Ä–µ—á–µ–Ω–Ω—è
- –ß—ñ—Ç–∫–µ "—Ç–∞–∫" –∞–±–æ "–Ω—ñ" –∑ –ø–æ—è—Å–Ω–µ–Ω–Ω—è–º
            """.trimIndent()
        }
    }
    
    private fun buildDebateEvaluationPrompt(
        topic: String,
        userPosition: String,
        rounds: List<Pair<String, String>>
    ): String {
        val transcript = rounds.mapIndexed { index, (user, ai) ->
            "–†–∞—É–Ω–¥ ${index + 1}:\n–û–ø–æ–Ω–µ–Ω—Ç (–ø–æ–∑–∏—Ü—ñ—è: $userPosition): $user\nAI: $ai"
        }.joinToString("\n\n")
        
        return """
–û—Ü—ñ–Ω–∏ –¥–µ–±–∞—Ç–∏ –Ω–∞ —Ç–µ–º—É: "$topic"

–¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç:
$transcript

–î–∞–π –∫–æ—Ä–æ—Ç–∫–∏–π —Ñ—ñ–¥–±–µ–∫ (3-4 —Ä–µ—á–µ–Ω–Ω—è):
1. –°–∏–ª—å–Ω—ñ —Å—Ç–æ—Ä–æ–Ω–∏ –∞—Ä–≥—É–º–µ–Ω—Ç–∞—Ü—ñ—ó –æ–ø–æ–Ω–µ–Ω—Ç–∞
2. –©–æ –º–æ–∂–Ω–∞ –ø–æ–∫—Ä–∞—â–∏—Ç–∏
3. –ó–∞–≥–∞–ª—å–Ω–∞ –æ—Ü—ñ–Ω–∫–∞ –≤–∏—Å—Ç—É–ø—É (1-10)

–§–æ—Ä–º–∞—Ç: –∫–æ—Ä–æ—Ç–∫–∏–π —Ç–µ–∫—Å—Ç —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é –º–æ–≤–æ—é
        """.trimIndent()
    }
}

enum class SalesStage {
    INITIAL_PITCH,
    HANDLING_OBJECTION
}
```

### 2. DebateTopicsProvider.kt

```kotlin
package com.aivoicepower.data.content

/**
 * Provider –¥–ª—è —Ç–µ–º –¥–µ–±–∞—Ç—ñ–≤
 */
object DebateTopicsProvider {
    
    data class DebateTopic(
        val id: String,
        val topic: String,
        val description: String,
        val difficulty: String
    )
    
    private val topics = listOf(
        DebateTopic(
            id = "debate_001",
            topic = "–®—Ç—É—á–Ω–∏–π —ñ–Ω—Ç–µ–ª–µ–∫—Ç: –∑–∞–≥—Ä–æ–∑–∞ —á–∏ –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å –¥–ª—è –ª—é–¥—Å—Ç–≤–∞?",
            description = "–û–±–≥–æ–≤–æ—Ä–µ–Ω–Ω—è –≤–ø–ª–∏–≤—É AI –Ω–∞ –º–∞–π–±—É—Ç–Ω—î —Å—É—Å–ø—ñ–ª—å—Å—Ç–≤–∞",
            difficulty = "–°–µ—Ä–µ–¥–Ω—è"
        ),
        DebateTopic(
            id = "debate_002",
            topic = "–ß–∏ –≤–∞—Ä—Ç–æ –∫–æ–ª–æ–Ω—ñ–∑—É–≤–∞—Ç–∏ –ú–∞—Ä—Å?",
            description = "–ê—Ä–≥—É–º–µ–Ω—Ç–∏ –∑–∞ —Ç–∞ –ø—Ä–æ—Ç–∏ –º—ñ–∂–ø–ª–∞–Ω–µ—Ç–Ω–æ—ó –∫–æ–ª–æ–Ω—ñ–∑–∞—Ü—ñ—ó",
            difficulty = "–°–µ—Ä–µ–¥–Ω—è"
        ),
        DebateTopic(
            id = "debate_003",
            topic = "–ë–µ–∑—É–º–æ–≤–Ω–∏–π –±–∞–∑–æ–≤–∏–π –¥–æ—Ö—ñ–¥: —É—Ç–æ–ø—ñ—è —á–∏ –Ω–µ–æ–±—Ö—ñ–¥–Ω—ñ—Å—Ç—å?",
            description = "–î–µ–±–∞—Ç–∏ –ø—Ä–æ –µ–∫–æ–Ω–æ–º—ñ—á–Ω—ñ —Å–∏—Å—Ç–µ–º–∏ –º–∞–π–±—É—Ç–Ω—å–æ–≥–æ",
            difficulty = "–°–∫–ª–∞–¥–Ω–∞"
        ),
        DebateTopic(
            id = "debate_004",
            topic = "–°–æ—Ü—ñ–∞–ª—å–Ω—ñ –º–µ—Ä–µ–∂—ñ —Ä–æ–±–ª—è—Ç—å –Ω–∞—Å –±—ñ–ª—å—à —Å–∞–º–æ—Ç–Ω—ñ–º–∏",
            description = "–í–ø–ª–∏–≤ —Å–æ—Ü–º–µ—Ä–µ–∂ –Ω–∞ –ø—Å–∏—Ö—ñ—á–Ω–µ –∑–¥–æ—Ä–æ–≤'—è",
            difficulty = "–õ–µ–≥–∫–∞"
        ),
        DebateTopic(
            id = "debate_005",
            topic = "–û–Ω–ª–∞–π–Ω-–æ—Å–≤—ñ—Ç–∞ –∫—Ä–∞—â–∞ –∑–∞ —Ç—Ä–∞–¥–∏—Ü—ñ–π–Ω—É",
            description = "–ú–∞–π–±—É—Ç–Ω—î –æ—Å–≤—ñ—Ç–Ω—å–æ—ó —Å–∏—Å—Ç–µ–º–∏",
            difficulty = "–õ–µ–≥–∫–∞"
        ),
        DebateTopic(
            id = "debate_006",
            topic = "–ß–∏ –ø–æ–≤–∏–Ω–Ω—ñ —Ä–æ–±–æ—Ç–∏ –º–∞—Ç–∏ –ø—Ä–∞–≤–∞?",
            description = "–ï—Ç–∏–∫–∞ —à—Ç—É—á–Ω–æ–≥–æ —ñ–Ω—Ç–µ–ª–µ–∫—Ç—É",
            difficulty = "–°–∫–ª–∞–¥–Ω–∞"
        ),
        DebateTopic(
            id = "debate_007",
            topic = "–ì–µ–Ω–µ—Ç–∏—á–Ω–∞ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ü—ñ—è –ª—é–¥–µ–π ‚Äî –µ—Ç–∏—á–Ω–æ –≤–∏–ø—Ä–∞–≤–¥–∞–Ω–∞",
            description = "–ú–µ–∂—ñ –±—ñ–æ—Ç–µ—Ö–Ω–æ–ª–æ–≥—ñ–π",
            difficulty = "–°–∫–ª–∞–¥–Ω–∞"
        ),
        DebateTopic(
            id = "debate_008",
            topic = "4-–¥–µ–Ω–Ω–∏–π —Ä–æ–±–æ—á–∏–π —Ç–∏–∂–¥–µ–Ω—å ‚Äî —Ü–µ –º–∞–π–±—É—Ç–Ω—î",
            description = "Work-life balance —Ç–∞ –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å",
            difficulty = "–õ–µ–≥–∫–∞"
        )
    )
    
    fun getAllTopics(): List<DebateTopic> = topics
    
    fun getRandomTopic(): DebateTopic = topics.random()
    
    fun getTopicById(id: String): DebateTopic? = topics.find { it.id == id }
}
```

### 3. SalesProductsProvider.kt

```kotlin
package com.aivoicepower.data.content

/**
 * Provider –¥–ª—è —Ç–æ–≤–∞—Ä—ñ–≤ –¥–ª—è –ø—Ä–æ–¥–∞–∂—É
 */
object SalesProductsProvider {
    
    data class SalesProduct(
        val id: String,
        val name: String,
        val description: String,
        val price: String,
        val isAbsurd: Boolean = false
    )
    
    data class CustomerProfile(
        val type: String,
        val description: String,
        val typicalObjections: List<String>
    )
    
    private val realProducts = listOf(
        SalesProduct(
            id = "product_001",
            name = "–û–Ω–ª–∞–π–Ω-–∫—É—Ä—Å –∑ –ø—É–±–ª—ñ—á–Ω–∏—Ö –≤–∏—Å—Ç—É–ø—ñ–≤",
            description = "12-—Ç–∏–∂–Ω–µ–≤–∞ –ø—Ä–æ–≥—Ä–∞–º–∞ –¥–ª—è —Ä–æ–∑–≤–∏—Ç–∫—É –Ω–∞–≤–∏—á–æ–∫ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü—ñ–π",
            price = "‚Ç¥4,999"
        ),
        SalesProduct(
            id = "product_002",
            name = "–°–º–∞—Ä—Ç-–≥–æ–¥–∏–Ω–Ω–∏–∫ –¥–ª—è —Ñ—ñ—Ç–Ω–µ—Å—É",
            description = "–ú–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ –∑–¥–æ—Ä–æ–≤'—è 24/7, GPS, –≤–æ–¥–æ–Ω–µ–ø—Ä–æ–Ω–∏–∫–Ω–∏–π",
            price = "‚Ç¥8,999"
        ),
        SalesProduct(
            id = "product_003",
            name = "–ü—ñ–¥–ø–∏—Å–∫–∞ –Ω–∞ –æ–Ω–ª–∞–π–Ω-–±—ñ–±–ª—ñ–æ—Ç–µ–∫—É",
            description = "10,000+ –∫–Ω–∏–∂–æ–∫ —Ç–∞ –∞—É–¥—ñ–æ–∫–Ω–∏–≥ —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é —Ç–∞ –∞–Ω–≥–ª—ñ–π—Å—å–∫–æ—é",
            price = "‚Ç¥199/–º—ñ—Å"
        ),
        SalesProduct(
            id = "product_004",
            name = "–†–æ–±–æ—Ç–∏–∑–æ–≤–∞–Ω–∏–π –ø–∏–ª–æ—Å–æ—Å",
            description = "–ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ –ø—Ä–∏–±–∏—Ä–∞–Ω–Ω—è, –∫–∞—Ä—Ç–æ–≥—Ä–∞—Ñ—É–≤–∞–Ω–Ω—è –∫–≤–∞—Ä—Ç–∏—Ä–∏",
            price = "‚Ç¥12,999"
        )
    )
    
    private val absurdProducts = listOf(
        SalesProduct(
            id = "absurd_001",
            name = "–ù–µ–≤–∏–¥–∏–º–∏–π –ø–∞—Ä–∞—Å–æ–ª—å–∫—É",
            description = "–ó–∞—Ö–∏—â–∞—î –≤—ñ–¥ –¥–æ—â—É –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é —Å–∏–ª–æ–≤–æ–≥–æ –ø–æ–ª—è",
            price = "‚Ç¥99,999",
            isAbsurd = true
        ),
        SalesProduct(
            id = "absurd_002",
            name = "–ú–∞—à–∏–Ω–∞ —á–∞—Å—É (–ª–∏—à–µ –≤ –º–∏–Ω—É–ª–µ)",
            description = "–ü–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è –Ω–∞ 24 –≥–æ–¥–∏–Ω–∏ –Ω–∞–∑–∞–¥, –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è",
            price = "‚Ç¥50,000",
            isAbsurd = true
        ),
        SalesProduct(
            id = "absurd_003",
            name = "–ß–∞—Ä—ñ–≤–Ω–∏–π –æ–ª—ñ–≤–µ—Ü—å",
            description = "–í—Å–µ, —â–æ –Ω–∞–º–∞–ª—é—î—à, —Å—Ç–∞—î —Ä–µ–∞–ª—å–Ω—ñ—Å—Ç—é (–º–∞–∫—Å. 10 —Å–º)",
            price = "‚Ç¥1,000,000",
            isAbsurd = true
        )
    )
    
    private val customerTypes = listOf(
        CustomerProfile(
            type = "–ó–∞–π–Ω—è—Ç–∏–π –ø—Ä–æ—Ñ–µ—Å—ñ–æ–Ω–∞–ª",
            description = "–¶—ñ–Ω—É—î —á–∞—Å, —à—É–∫–∞—î –µ—Ñ–µ–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å",
            typicalObjections = listOf("–£ –º–µ–Ω–µ –Ω–µ–º–∞—î —á–∞—Å—É", "–¶–µ –¥–æ—Ä–æ–≥–æ", "–ß–∏ –¥—ñ–π—Å–Ω–æ —Ü–µ –ø—Ä–∞—Ü—é—î?")
        ),
        CustomerProfile(
            type = "–°–∫–µ–ø—Ç–∏–∫",
            description = "–ù–µ –¥–æ–≤—ñ—Ä—è—î –Ω–æ–≤–∏–º –ø—Ä–æ–¥—É–∫—Ç–∞–º, –ø–æ—Ç—Ä–µ–±—É—î –¥–æ–∫–∞–∑—ñ–≤",
            typicalObjections = listOf("–Ø —á—É–≤ –Ω–µ–≥–∞—Ç–∏–≤–Ω—ñ –≤—ñ–¥–≥—É–∫–∏", "–¶–µ —Å—Ö–æ–∂–µ –Ω–∞ –æ–±–º–∞–Ω", "–ù–∞–≤—ñ—â–æ –º–µ–Ω—ñ —Ü–µ?")
        ),
        CustomerProfile(
            type = "–û–±–µ—Ä–µ–∂–Ω–∏–π –ø–æ–∫—É–ø–µ—Ü—å",
            description = "–•–æ—á–µ –≤—Å–µ –∑–≤–∞–∂–∏—Ç–∏, –±–æ—ó—Ç—å—Å—è –ø–æ–º–∏–ª–∏—Ç–∏—Å—è",
            typicalObjections = listOf("–ú–æ–∂–µ, —è –ø–æ–¥—É–º–∞—é", "–©–æ —è–∫—â–æ —Ü–µ –º–µ–Ω—ñ –Ω–µ –ø—ñ–¥—ñ–π–¥–µ?", "–ß–∏ –º–æ–∂–Ω–∞ –ø–æ–≤–µ—Ä–Ω—É—Ç–∏?")
        ),
        CustomerProfile(
            type = "–ï–Ω—Ç—É–∑—ñ–∞—Å—Ç",
            description = "–¶—ñ–∫–∞–≤–∏–π –Ω–æ–≤–∏–Ω–∫–∞–º–∏, –∞–ª–µ –∫—Ä–∏—Ç–∏—á–Ω–æ —Å—Ç–∞–≤–∏—Ç—å—Å—è –¥–æ –¥–µ—Ç–∞–ª–µ–π",
            typicalObjections = listOf("–ê —â–æ —â–µ –≤—ñ–Ω –≤–º—ñ—î?", "–ß–∏ —î –∞–Ω–∞–ª–æ–≥–∏?", "–Ø–∫—ñ –≥–∞—Ä–∞–Ω—Ç—ñ—ó?")
        )
    )
    
    fun getAllProducts(includeAbsurd: Boolean = true): List<SalesProduct> {
        return if (includeAbsurd) {
            realProducts + absurdProducts
        } else {
            realProducts
        }
    }
    
    fun getRandomProduct(includeAbsurd: Boolean = true): SalesProduct {
        return getAllProducts(includeAbsurd).random()
    }
    
    fun getRandomCustomer(): CustomerProfile = customerTypes.random()
}
```

### 4. DebateState.kt

```kotlin
package com.aivoicepower.ui.screens.improvisation

import com.aivoicepower.data.content.DebateTopicsProvider

data class DebateState(
    val selectedTopic: DebateTopicsProvider.DebateTopic? = null,
    val userPosition: DebatePosition? = null,
    val phase: DebatePhase = DebatePhase.TopicSelection,
    val currentRound: Int = 1,
    val maxRounds: Int = 5,
    val rounds: List<DebateRound> = emptyList(),
    val isRecording: Boolean = false,
    val isAiThinking: Boolean = false,
    val recordingPath: String? = null,
    val recordingSeconds: Int = 0,
    val maxRecordingSeconds: Int = 60,
    val error: String? = null
)

enum class DebatePosition {
    FOR,        // –ó–ê
    AGAINST     // –ü–†–û–¢–ò
}

sealed class DebatePhase {
    object TopicSelection : DebatePhase()
    object PositionSelection : DebatePhase()
    object UserArgument : DebatePhase()
    object AiResponse : DebatePhase()
    object DebateComplete : DebatePhase()
}

data class DebateRound(
    val roundNumber: Int,
    val userArgument: String,
    val userRecordingPath: String,
    val aiResponse: String
)
```

### 5. DebateEvent.kt

```kotlin
package com.aivoicepower.ui.screens.improvisation

import com.aivoicepower.data.content.DebateTopicsProvider

sealed class DebateEvent {
    data class TopicSelected(val topic: DebateTopicsProvider.DebateTopic) : DebateEvent()
    data class PositionSelected(val position: DebatePosition) : DebateEvent()
    object StartRecordingClicked : DebateEvent()
    object StopRecordingClicked : DebateEvent()
    data class ArgumentTranscribed(val text: String) : DebateEvent()
    object NextRoundClicked : DebateEvent()
    object FinishDebateClicked : DebateEvent()
}
```

### 6. DebateViewModel.kt

```kotlin
package com.aivoicepower.ui.screens.improvisation

import android.content.Context
import android.os.Bundle
import android.speech.RecognitionListener
import android.speech.RecognizerIntent
import android.speech.SpeechRecognizer
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.aivoicepower.data.local.database.dao.RecordingDao
import com.aivoicepower.data.local.database.entity.RecordingEntity
import com.aivoicepower.data.local.datastore.UserPreferencesDataStore
import com.aivoicepower.data.remote.GeminiApiClient
import com.aivoicepower.utils.audio.AudioRecorderUtil
import dagger.hilt.android.lifecycle.HiltViewModel
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import java.util.*
import javax.inject.Inject

@HiltViewModel
class DebateViewModel @Inject constructor(
    @ApplicationContext private val context: Context,
    private val geminiApiClient: GeminiApiClient,
    private val recordingDao: RecordingDao,
    private val userPreferencesDataStore: UserPreferencesDataStore
) : ViewModel() {
    
    private val _state = MutableStateFlow(DebateState())
    val state: StateFlow<DebateState> = _state.asStateFlow()
    
    private val audioRecorder = AudioRecorderUtil(context)
    private var speechRecognizer: SpeechRecognizer? = null
    
    override fun onCleared() {
        super.onCleared()
        audioRecorder.release()
        speechRecognizer?.destroy()
    }
    
    fun onEvent(event: DebateEvent) {
        when (event) {
            is DebateEvent.TopicSelected -> {
                _state.update {
                    it.copy(
                        selectedTopic = event.topic,
                        phase = DebatePhase.PositionSelection
                    )
                }
            }
            is DebateEvent.PositionSelected -> {
                _state.update {
                    it.copy(
                        userPosition = event.position,
                        phase = DebatePhase.UserArgument,
                        currentRound = 1
                    )
                }
            }
            DebateEvent.StartRecordingClicked -> {
                startRecording()
            }
            DebateEvent.StopRecordingClicked -> {
                stopRecording()
            }
            is DebateEvent.ArgumentTranscribed -> {
                handleTranscribedArgument(event.text)
            }
            DebateEvent.NextRoundClicked -> {
                startNextRound()
            }
            DebateEvent.FinishDebateClicked -> {
                finishDebate()
            }
        }
    }
    
    private fun startRecording() {
        viewModelScope.launch {
            try {
                val outputFile = context.filesDir.resolve("recordings/${UUID.randomUUID()}.m4a")
                outputFile.parentFile?.mkdirs()
                
                audioRecorder.startRecording(outputFile.absolutePath)
                
                _state.update {
                    it.copy(
                        isRecording = true,
                        recordingPath = outputFile.absolutePath,
                        recordingSeconds = 0
                    )
                }
                
                // Timer
                var elapsed = 0
                while (elapsed < _state.value.maxRecordingSeconds && _state.value.isRecording) {
                    delay(1000)
                    elapsed++
                    _state.update { it.copy(recordingSeconds = elapsed) }
                }
                
                if (elapsed >= _state.value.maxRecordingSeconds) {
                    stopRecording()
                }
            } catch (e: Exception) {
                _state.update {
                    it.copy(
                        error = "–ü–æ–º–∏–ª–∫–∞ –∑–∞–ø–∏—Å—É: ${e.message}",
                        isRecording = false
                    )
                }
            }
        }
    }
    
    private fun stopRecording() {
        viewModelScope.launch {
            try {
                audioRecorder.stopRecording()
                _state.update { it.copy(isRecording = false) }
                
                // Start transcription
                startTranscription()
            } catch (e: Exception) {
                _state.update {
                    it.copy(
                        error = "–ü–æ–º–∏–ª–∫–∞ –∑—É–ø–∏–Ω–∫–∏: ${e.message}",
                        isRecording = false
                    )
                }
            }
        }
    }
    
    private fun startTranscription() {
        if (speechRecognizer == null) {
            speechRecognizer = SpeechRecognizer.createSpeechRecognizer(context)
        }
        
        val intent = android.content.Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {
            putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)
            putExtra(RecognizerIntent.EXTRA_LANGUAGE, "uk-UA")
        }
        
        speechRecognizer?.setRecognitionListener(object : RecognitionListener {
            override fun onResults(results: Bundle?) {
                val matches = results?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)
                val transcription = matches?.firstOrNull() ?: "–ù–µ –≤–¥–∞–ª–æ—Å—å —Ä–æ–∑–ø—ñ–∑–Ω–∞—Ç–∏ –º–æ–≤–ª–µ–Ω–Ω—è"
                onEvent(DebateEvent.ArgumentTranscribed(transcription))
            }
            
            override fun onError(error: Int) {
                _state.update {
                    it.copy(error = "–ü–æ–º–∏–ª–∫–∞ —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è –º–æ–≤–ª–µ–Ω–Ω—è")
                }
            }
            
            override fun onReadyForSpeech(params: Bundle?) {}
            override fun onBeginningOfSpeech() {}
            override fun onRmsChanged(rmsdB: Float) {}
            override fun onBufferReceived(buffer: ByteArray?) {}
            override fun onEndOfSpeech() {}
            override fun onPartialResults(partialResults: Bundle?) {}
            override fun onEvent(eventType: Int, params: Bundle?) {}
        })
        
        // For now, simulate transcription (SpeechRecognizer can be flaky)
        viewModelScope.launch {
            delay(2000)
            onEvent(DebateEvent.ArgumentTranscribed("[–ê—Ä–≥—É–º–µ–Ω—Ç –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ - —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü—ñ—è]"))
        }
    }
    
    private fun handleTranscribedArgument(transcription: String) {
        viewModelScope.launch {
            _state.update { it.copy(isAiThinking = true, phase = DebatePhase.AiResponse) }
            
            try {
                val topic = _state.value.selectedTopic?.topic ?: ""
                val position = when (_state.value.userPosition) {
                    DebatePosition.FOR -> "–ó–ê"
                    DebatePosition.AGAINST -> "–ü–†–û–¢–ò"
                    else -> ""
                }
                val roundNumber = _state.value.currentRound
                val history = _state.value.rounds.map { it.userArgument to it.aiResponse }
                
                val result = geminiApiClient.generateDebateResponse(
                    topic = topic,
                    userPosition = position,
                    userArgument = transcription,
                    roundNumber = roundNumber,
                    conversationHistory = history
                )
                
                result.onSuccess { aiResponse ->
                    val newRound = DebateRound(
                        roundNumber = roundNumber,
                        userArgument = transcription,
                        userRecordingPath = _state.value.recordingPath ?: "",
                        aiResponse = aiResponse
                    )
                    
                    // Save recording to DB
                    saveRecording(transcription)
                    
                    _state.update {
                        it.copy(
                            rounds = it.rounds + newRound,
                            isAiThinking = false,
                            recordingPath = null
                        )
                    }
                }.onFailure { error ->
                    _state.update {
                        it.copy(
                            error = "–ü–æ–º–∏–ª–∫–∞ AI: ${error.message}",
                            isAiThinking = false
                        )
                    }
                }
            } catch (e: Exception) {
                _state.update {
                    it.copy(
                        error = "–ü–æ–º–∏–ª–∫–∞: ${e.message}",
                        isAiThinking = false
                    )
                }
            }
        }
    }
    
    private suspend fun saveRecording(transcription: String) {
        try {
            val recordingPath = _state.value.recordingPath ?: return
            val topic = _state.value.selectedTopic?.id ?: ""
            
            val recordingEntity = RecordingEntity(
                id = UUID.randomUUID().toString(),
                filePath = recordingPath,
                durationMs = _state.value.recordingSeconds * 1000L,
                type = "improvisation",
                contextId = "debate_$topic",
                transcription = transcription,
                isAnalyzed = false
            )
            
            recordingDao.insert(recordingEntity)
        } catch (e: Exception) {
            // Log error
        }
    }
    
    private fun startNextRound() {
        val nextRound = _state.value.currentRound + 1
        if (nextRound <= _state.value.maxRounds) {
            _state.update {
                it.copy(
                    currentRound = nextRound,
                    phase = DebatePhase.UserArgument,
                    recordingSeconds = 0
                )
            }
        } else {
            finishDebate()
        }
    }
    
    private fun finishDebate() {
        viewModelScope.launch {
            try {
                userPreferencesDataStore.incrementFreeImprovisations()
                _state.update { it.copy(phase = DebatePhase.DebateComplete) }
            } catch (e: Exception) {
                _state.update { it.copy(error = "–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è: ${e.message}") }
            }
        }
    }
}
```

### 7. DebateScreen.kt (—Å–∫–æ—Ä–æ—á–µ–Ω–∞ –≤–µ—Ä—Å—ñ—è)

```kotlin
package com.aivoicepower.ui.screens.improvisation

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.aivoicepower.data.content.DebateTopicsProvider
import com.aivoicepower.ui.screens.improvisation.components.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DebateScreen(
    viewModel: DebateViewModel = hiltViewModel(),
    onNavigateBack: () -> Unit
) {
    val state by viewModel.state.collectAsStateWithLifecycle()
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("–î–µ–±–∞—Ç–∏ –∑ AI") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "–ù–∞–∑–∞–¥")
                    }
                }
            )
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            when (state.phase) {
                DebatePhase.TopicSelection -> {
                    TopicSelectionContent(
                        topics = DebateTopicsProvider.getAllTopics(),
                        onTopicSelected = { viewModel.onEvent(DebateEvent.TopicSelected(it)) }
                    )
                }
                
                DebatePhase.PositionSelection -> {
                    PositionSelectionContent(
                        topic = state.selectedTopic!!,
                        onPositionSelected = { viewModel.onEvent(DebateEvent.PositionSelected(it)) }
                    )
                }
                
                DebatePhase.UserArgument -> {
                    UserArgumentContent(
                        topic = state.selectedTopic!!,
                        position = state.userPosition!!,
                        roundNumber = state.currentRound,
                        isRecording = state.isRecording,
                        secondsElapsed = state.recordingSeconds,
                        maxSeconds = state.maxRecordingSeconds,
                        onStartRecording = { viewModel.onEvent(DebateEvent.StartRecordingClicked) },
                        onStopRecording = { viewModel.onEvent(DebateEvent.StopRecordingClicked) }
                    )
                }
                
                DebatePhase.AiResponse -> {
                    AiResponseContent(
                        isThinking = state.isAiThinking,
                        rounds = state.rounds,
                        currentRound = state.currentRound,
                        maxRounds = state.maxRounds,
                        onNextRound = { viewModel.onEvent(DebateEvent.NextRoundClicked) },
                        onFinish = { viewModel.onEvent(DebateEvent.FinishDebateClicked) }
                    )
                }
                
                DebatePhase.DebateComplete -> {
                    DebateCompleteContent(
                        topic = state.selectedTopic!!,
                        rounds = state.rounds,
                        onFinish = onNavigateBack
                    )
                }
            }
        }
    }
}
```

### 8. SalesPitchState.kt, ViewModel, Screen - –∞–Ω–∞–ª–æ–≥—ñ—á–Ω–æ DebateState

_(–ö–æ–¥ SalesPitch –¥—É–∂–µ —Å—Ö–æ–∂–∏–π –Ω–∞ Debate, —Ç—ñ–ª—å–∫–∏ –∑ —ñ–Ω—à–∏–º–∏ phases —Ç–∞ prompt logic. –î–ª—è –µ–∫–æ–Ω–æ–º—ñ—ó –º—ñ—Å—Ü—è –Ω–µ –¥—É–±–ª—é—é –ø–æ–≤–Ω–∏–π –∫–æ–¥, –∞–ª–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —ñ–¥–µ–Ω—Ç–∏—á–Ω–∞)_

---

## ‚ö†Ô∏è –í–ê–ñ–õ–ò–í–Ü –ù–û–¢–ê–¢–ö–ò

### API Key Management

```kotlin
// TODO: –ù–ï commit–∏—Ç–∏ API key –≤ Git!
// –í–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –æ–¥–∏–Ω –∑ –≤–∞—Ä—ñ–∞–Ω—Ç—ñ–≤:

// 1. local.properties
GEMINI_API_KEY=your_key_here

// 2. BuildConfig
android {
    buildTypes {
        debug {
            buildConfigField("String", "GEMINI_API_KEY", "\"${properties["GEMINI_API_KEY"]}\"")
        }
    }
}

// 3. Secure storage (–¥–ª—è –ø—Ä–æ–¥–∞–∫—à–µ–Ω—É)
```

### Permissions –≤ AndroidManifest.xml

```xml
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.RECORD_AUDIO" />
```

### Gradle Dependencies

```kotlin
dependencies {
    // Gemini API
    implementation("com.google.ai.client.generativeai:generativeai:0.9.0")
    
    // Coroutines
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")
}
```

---

## –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è

### 1. Mock Mode (–±–µ–∑ API key)

–°—Ç–≤–æ—Ä–∏—Ç–∏ `GeminiApiClientMock.kt` –¥–ª—è —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è UI –±–µ–∑ API:

```kotlin
class GeminiApiClientMock : GeminiApiClient {
    override suspend fun generateDebateResponse(...): Result<String> {
        delay(2000) // Simulate network
        return Result.success("–¶–µ mock –≤—ñ–¥–ø–æ–≤—ñ–¥—å AI. –¢–≤—ñ–π –∞—Ä–≥—É–º–µ–Ω—Ç —Ü—ñ–∫–∞–≤–∏–π, –∞–ª–µ...")
    }
}
```

### 2. Error Handling

- [ ] Network error ‚Üí –ø–æ–∫–∞–∑–∞—Ç–∏ retry
- [ ] API rate limit ‚Üí –ø–æ—è—Å–Ω–∏—Ç–∏ –ª—ñ–º—ñ—Ç
- [ ] Empty response ‚Üí fallback message

### 3. UI/UX

- [ ] Loading states (AI thinking)
- [ ] Smooth transitions –º—ñ–∂ —Ñ–∞–∑–∞–º–∏
- [ ] Clear feedback –Ω–∞ –∫–æ–∂–µ–Ω –∫—Ä–æ–∫

---

## –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞

```bash
./gradlew assembleDebug
```

**Testing Checklist:**

**Debate:**
- [ ] Topic selection –ø—Ä–∞—Ü—é—î
- [ ] Position selection –ø—Ä–∞—Ü—é—î
- [ ] Recording + transcription
- [ ] AI response –æ—Ç—Ä–∏–º—É—î—Ç—å—Å—è
- [ ] Multiple rounds –ø—Ä–∞—Ü—é—é—Ç—å
- [ ] Debate complete summary

**Sales Pitch:**
- [ ] Product selection
- [ ] Customer profile generation
- [ ] Opening pitch recording
- [ ] AI objection generation
- [ ] Handling objection recording
- [ ] AI decision (–∫—É–ø—É—î/–Ω–µ –∫—É–ø—É—î)

---

## –û—á—ñ–∫—É–≤–∞–Ω–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç

‚úÖ GeminiApiClient –∑ 3 –º–µ—Ç–æ–¥–∞–º–∏
‚úÖ Debate Screen (5 phases)
‚úÖ Sales Pitch Screen (interactive)
‚úÖ Content providers (8 debate topics, products, customers)
‚úÖ Turn-based AI conversation –ø—Ä–∞—Ü—é—î
‚úÖ Premium feature (—Ü—ñ —Ä–µ–∂–∏–º–∏ –¥–æ—Å—Ç—É–ø–Ω—ñ —Ç—ñ–ª—å–∫–∏ –¥–ª—è Premium)

---

## üéâ PHASE 5 –ó–ê–í–ï–†–®–ï–ù–û!

```
‚úÖ Phase 5.1 ‚Äî Improvisation Hub + Random Topic
‚úÖ Phase 5.2 ‚Äî Storytelling + Daily Challenge
‚úÖ Phase 5.3 ‚Äî Debate + Sales Pitch (AI-interactive)
```

**–í—Å—ñ 5 —Ä–µ–∂–∏–º—ñ–≤ —ñ–º–ø—Ä–æ–≤—ñ–∑–∞—Ü—ñ—ó –≥–æ—Ç–æ–≤—ñ!**

---

## üöÄ –ù–∞—Å—Ç—É–ø–Ω–∏–π –∫—Ä–æ–∫: Phase 6

**Phase 6: AI Coach** ‚Äî –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—î —Ç—É —Å–∞–º—É GeminiApiClient infrastructure:
- Chat interface
- Context-aware responses (–∑–Ω–∞—î UserProgress)
- Message history
- Quick actions

**–°–∫–ª–∞–¥–Ω—ñ—Å—Ç—å:** üî¥ –í–ò–°–û–ö–ê  
**–ß–∞—Å:** ‚è±Ô∏è 8-10 –≥–æ–¥–∏–Ω (2-3 –ø—ñ–¥—Ñ–∞–∑–∏)

---

**–ß–∞—Å –Ω–∞ Phase 5.3:** ~4-5 –≥–æ–¥–∏–Ω

**–ü—Ä–∏–º—ñ—Ç–∫–∞:** –¶–µ proof of concept –¥–ª—è AI integration. Phase 6 –±—É–¥–µ —Å—Ö–æ–∂–∏–º –ø—ñ–¥—Ö–æ–¥–æ–º.